import cv2
import numpy as np
import RPi.GPIO as GPIO
import pygame
import time
import imutils 

# Setup de pines
GPIO.setmode(GPIO.BCM)

GPIO_TRIGGER = 18
GPIO_ECHO = 24

GPIO.setwarnings(False)
GPIO.setup(2,GPIO.OUT)
GPIO.setup(3,GPIO.OUT)
GPIO.setup(4,GPIO.OUT)
GPIO.setup(GPIO_TRIGGER, GPIO.OUT)
GPIO.setup(GPIO_ECHO, GPIO.IN)

# Funcion para medir distancia con sensor
def distance():
    # set Trigger to HIGH
    GPIO.output(GPIO_TRIGGER, True)
 
    # set Trigger after 0.01ms to LOW
    time.sleep(0.00001)
    GPIO.output(GPIO_TRIGGER, False)
 
    StartTime = time.time()
    StopTime = time.time()
 
    # save StartTime
    while GPIO.input(GPIO_ECHO) == 0:
        StartTime = time.time()
 
    # save time of arrival
    while GPIO.input(GPIO_ECHO) == 1:
        StopTime = time.time()
 
    # time difference between start and arrival
    TimeElapsed = StopTime - StartTime
    # multiply with the sonic speed (34300 cm/s)
    # and divide by 2, because there and back
    distance = (TimeElapsed * 34300) / 2
 
    return distance

# Funcion para eventos del mouse
def clics(event,x,y,flags,param):
    global puntos
    if event == cv2.EVENT_LBUTTONDOWN:
        puntos.append([x,y])
# Funcion para dibujar circulo del click        
def dibujando_puntos(puntos):
    for x, y in puntos:
        cv2.circle(frame,(x,y),5,(0,255,0),2)
# Funcion para unir los puntos del click        
def uniendo4puntos(puntos):
    cv2.line(frame,tuple(puntos[0]),tuple(puntos[1]),(255,0,0),1)
    cv2.line(frame,tuple(puntos[0]),tuple(puntos[2]),(255,0,0),1)
    cv2.line(frame,tuple(puntos[2]),tuple(puntos[3]),(255,0,0),1)
    cv2.line(frame,tuple(puntos[1]),tuple(puntos[3]),(255,0,0),1)
puntos = []

cap = cv2.VideoCapture(0)
#cap = cv2.VideoCapture('prueba.mp4')
cv2.namedWindow('frame')
cv2.setMouseCallback('frame',clics)
a = 0
while True:
    ret, frame = cap.read()
    if ret == False: break
    dibujando_puntos(puntos)
    if len(puntos) == 4:
        uniendo4puntos(puntos)
        pts1 = np.float32([puntos])
        pts2 = np.float32([[0,0], [500,0], [0,500], [500,500]])
        M = cv2.getPerspectiveTransform(pts1,pts2)
        dst = cv2.warpPerspective(frame, M, (500,500))
#         cv2.imshow('dst', dst) 
#         gray = cv2.cvtColor(dst, cv2.COLOR_BGR2GRAY)

        # Dibujamos un rectángulo en frame
        cv2.rectangle(dst,(0,0),(dst.shape[1],40),(0,0,0),-1)
        color = (0, 255, 0)
        color1 = (255,0,0) 
#          Especificamos los puntos extremos del área a analizar
        area_pts = np.array([[500,500], [500,0], [0,0], [0,500]])
    
        # Visuzalizamos el alrededor del área que vamos a analizar       
        image=cv2.drawContours(dst, [area_pts], -1, color, 2)
        #cv2.imshow("grsis", image)
        grises = cv2.cvtColor(dst, cv2.COLOR_BGR2GRAY)
       # cv2.imshow("gris", grises)
        _,th =  cv2.threshold(grises, 120, 255, cv2.THRESH_BINARY_INV)
        cnts,_ = cv2.findContours(th, cv2.RETR_EXTERNAL,
                      cv2.CHAIN_APPROX_SIMPLE)
        conteo = 0
        a = 0
        cv2.imshow('area',th)
        for cnt in cnts:
            area = cv2.contourArea(cnt)
#             Conteo de personas 
            if area > 200: 
                M = cv2.moments(cnt)
                if (M["m00"]==0): M["m00"]==1
                x = int(M["m10"]/M["m00"])
                y = int(M["m01"]/M["m00"])
                x, y, w, h = cv2.boundingRect(cnt)
                cv2.rectangle(dst, (x,y), (x+w, y+h),(0,255,0), 2)
#                 puntos.append([x, y, w, h])
               # cv2.drawContours(dst, [cnt], 0, color, 2)
                conteo += 1
                cv2.putText(dst, str(conteo), (x-10,y+10), 1, 2,(255,0,0),2)
                color = (0, 0, 255)   
        texto_conteo = "Numero de personas =" + str(conteo - 1)                               
        texto_maximo = "Aviso! Maximo de personas"
        maximo = conteo -1
#         print('Numero de personas en el salon =',conteo-1)
        
#         Control de personas en el area
        if maximo <= 10:
            cv2.putText(dst, texto_conteo , (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, color1,2)             
            GPIO.output(2,GPIO.HIGH)
            GPIO.output(4,GPIO.LOW)
            GPIO.output(3,GPIO.LOW)
        else:
            cv2.putText(dst, texto_maximo , (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, color,2)             
            GPIO.output(2,GPIO.LOW)
            GPIO.output(4,GPIO.LOW)
            GPIO.output(3,GPIO.HIGH)
            a = 1
        cv2.imshow("rectangulos", dst)

    cv2.imshow("frame", frame)
    if a == 1:
#             Audio maximo personas
        pygame.mixer.init()
        pygame.mixer.music.load("maximo.wav")
        pygame.mixer.music.play()
        while pygame.mixer.music.get_busy() == True:
            continue
#     Distancia con Sensor 
    dist = distance()
    if dist < 20:
#         print("Guarde su distancia")
#         Audio distancia minima
        GPIO.output(2,GPIO.LOW)
        GPIO.output(3,GPIO.LOW)
        GPIO.output(4,GPIO.HIGH)
        pygame.mixer.init()
        pygame.mixer.music.load("distancia.wav")
        pygame.mixer.music.play()
        while pygame.mixer.music.get_busy() == True:
                continue
#         print ("Distance = %.1f cm" % dist)
        time.sleep(1)
        
    k = cv2.waitKey(1) & 0xFF
    
    if k == ord('n'): # Limpiar el contenido de la frame
        puntos = []
        
    elif k == 27:
        break
cap.release()
cv2.destroyAllWindows()
